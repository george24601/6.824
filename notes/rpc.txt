server must eventually discard info about old RPCs
    when is discard safe?
    idea:
      unique client IDs
      per-client RPC sequence numbers
      client includes "seen all replies <= X" with every RPC
      much like TCP sequence #s and acks

   or only allow client one outstanding RPC at a time
      arrival of seq+1 allows server to discard all <= seq
    or client agrees to keep retrying for < 5 minutes
      server discards after 5+ minutes

  how to handle dup req while original is still executing?
    server doesn't know reply yet; don't want to run twice
    idea: "pending" flag per executing RPC; wait or ignore

each thread includes some per-thread state:
    program counter, registers, stack

-----
RPC overview
  many examples in test_test.go
    e.g., TestBasic()
  application calls Call()
     reply := end.Call("Raft.AppendEntries", args, &reply) --   send an RPC, wait for reply
  servers side:
     srv := MakeServer()
     srv.AddService(svc) -- a server can have multiple services, e.g. Raft and k/v
       pass srv to net.AddServer()
     svc := MakeService(receiverObject) -- obj's methods will handle RPCs
       much like Go's rpcs.Register()
       pass svc to srv.AddService()

----

AddService
  add a service name
  Q: why a lock?
  Q: what is defer()?
  
Dispatch
  dispatch a request to the right service
  Q: why hold a lock?
  Q: why not hold lock to end of function?

Call():
  Use reflect to find type of argument
  Use gob marshall argument
  e.ch is the channel to the network to send request
  Make a channel to receive reply from network ( <- req.replyCh)

MakeEnd():
  has a thread/goroutine that simulates the network
    reads from e.ch and process requests
    each requests is processed in a separate goroutine
      Q: can an end point have many outstanding requests?
    Q: why rn.mu.Lock()?
    Q: what does lock protect?

ProcessReq():
  finds server endpoint
  if network unreliable, may delay and drop requests,
  dispatch request to server in a new thread
  waits on reply by reading ech or until 100 msec has passed
    100 msec just to see if server is dead
  then return reply
    Q: who will read the reply?
  Q: is ok that ProcessReq doesn't hold rn lock?

Service.dispatch():
 find method for a request
 unmarshall arguments
 call method
 marshall reply
 return reply

Study the Go tutorials on goroutines and channels
  Use Go's race detector:
    https://golang.org/doc/articles/race_detector.html
    go test --race mypkg
